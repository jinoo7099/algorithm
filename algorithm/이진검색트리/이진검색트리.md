# 이진 검색 트리

왼쪽 서브트리의 모든 값은 부모의 값보다 작고
오른쪽 서브트리의 모든 값은 부모의 값보다 크다.


## 특징

insert, erase, find, update -> O(logN)

원소가 크기 순으로 정렬되어 있음
-> preOrder로 돌면 오름차순으로 조회 가능

반대로 해시는 크기 순으로 정렬되어 있지 않음

# 구현

## insert

이진 검색 트리 특성에 따라 왼쪽에 삽입할지 오른쪽 삽입할지 대소비교를 통해 이어나감

## erase

case 1. 자식이 없는 정점
그냥 지워도 구조를 망가트리지 않음

case 2. 자식이 1개인 정점
자식을 지워진 노드 자리에 올리면 됨

**case 3. 자식이 2개인 정점**

오른쪽 서브트리에서 가장 작은 값을 해당 정점 위치에 삽입하고, 
이동한 자식의 자식도 부모의 위치로 이동시킨다.

오른쪽 서브트리의 가장 왼쪽 정점
or 왼쪽 서브트리의 가장 오른쪽 정점

# 자가 균형 트리

AVL or 레드블랙 트리로 구현가능

우리가 구현한 이진 검색 트리를 그대로 사용할 시 성능이 비효율적임
-> 편형성이 생김
-> 연산들이 O(N) 동작할 수도 있음

# STL

## Set

insert
erase
find
size
count

// iterator
prev it의 전 포인터
next it의 후 포인터
advance(it, number) it에서 number만큼 이동
lower_bound, upper_bound, equal_range

set의 웬만한 연산은 모두 O(logN) 이다.

## multiset

원소의 중복이 허용되는 set

find 연산을 수행할때 어떤 원소를 반환할지 랜덤임
-> 표준에서도 어떤 원소를 반환할지 모른다고 적혀있음
-> 실험으로는 일치하는 원소 중 제일 앞에 원소를 가져오지만 주의해야함


### erase 주의

```c++
multiset<int> ms;

ms.erase(ms.begin()); // 첫번째 원소 삭제

주의
**// ms.erase(*ms.begin()) // 최소값이 여러개일때 모두 삭제**
```

## map

key-value 

만약 문제를 풀다가 set, map 느낌의 성질이 필요하면서 특히 lower_bound, prev, next를 써야될거 같으면 set, map을 써야함

반면 그냥 key로 value를 빠르게 찾거나 원소의 삽입/검색/삭제만 빠르게 처리해야할 상황이면 unordered를 쓰자

평균적으로 unordered가 빠르긴 한다.
하지만 충돌 여부에 따라 속도 저하가 발생할 수도 있음

출제자가 충돌을 유도해 O(1) 연산을 O(N)으로 내는 경우도 종종 있음

반면 set/map이 평균적으로 느릴지어도 항상 O(logN)이라 안정적임
+ 이진검색트리의 연산은 상당히 무겁기 떄문에 우리가 아는 logN보다는 느리다는 걸 명심하자

# 정리

이진 검색 트리에서는 원소가 크기 순으로 저장되어 있음
삽입/삭제/검색이 모두 O(logN)으로 동작

N의 크기가 클때 원소의 대소관계가 필요한데 삽입 혹은 삭제가 빈번하다면 이진 검색 트리가 적합함

