# 플로이드 알고리즘

무방향 or 방향 그래프 사이에서
모든 정점 쌍 사이의 최단 거리를 구하는 알고리즘

# 구현

- 인접행렬 이용
- 음수여도 동작하지만, 음수 사이클이 존재하면 동작 x

1. 최단 거리 테이블에서 당장 채울 수 있는 것들은 채워넣음
   1. 자기자신
   2. 인접 정점과 거리(가중치)
   3. 인접하지 않은 정점 -> 무한대
2. 1 ~ V에서 i번 정점를 거쳐가는 최단 거리를 생각해야됨
   1. 현재 테이블의 상태는 중간에 다른 정점을 거치지 않은 테이블임
   2. i번 정점을 거쳐서 정점간에 최단거리를 갱신하자

# 시간복잡도

정점이 V개라고 할 때 V단계에 걸쳐 갱신이 이루어지고
총 V^2개의 D[s][t]값을 D[s][k] + D[k][t]와 비교하기 떄문에
O(V^3) 이다.

정점 1000개 까지는 커버됨

# 최적화

연산보다 대입이 느리다.
대입을 최대한 줄이면 최적화 가능
갱신이 필요할 때만 갱신하도록

```c++
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

->

if(d[i][j] > d[i][k] + d[k][j]) {
    d[i][j] = d[i][k] + d[k][j];
}
```

# 경로 복원

a에서 b까지 최단 거리로 가는 전체 경로

- nxt 테이블을 만들자.
-
